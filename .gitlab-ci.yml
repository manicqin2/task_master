# GitLab CI/CD Pipeline Configuration
# Feature: 002-gitlab-security-pipeline
# Purpose: Automated security scanning (Secret Detection, Dependency Scanning, SAST)
#
# GitLab Tier Requirements:
# - Secret Detection: FREE tier ‚úì
# - SAST: FREE tier ‚úì
# - Dependency Scanning: ULTIMATE tier (requires license)
#
# Documentation:
# - Secret Detection: https://docs.gitlab.com/ee/user/application_security/secret_detection/
# - Dependency Scanning: https://docs.gitlab.com/ee/user/application_security/dependency_scanning/
# - SAST: https://docs.gitlab.com/ee/user/application_security/sast/
#
# ==============================================================================
# Edge Case Handling (T072-T079)
# ==============================================================================
#
# 1. Gitignored Files with Secrets (T072)
# Problem: Developer accidentally stages .env file with secrets
# Solution: Secret detection scans git index, catches even .gitignored files if staged
# Action: Pipeline will block and warn developer to unstage the file
# Prevention: Add pre-commit hooks to prevent staging .gitignored files with secrets
#
# 2. Large Binary Files (T073)
# Problem: Binary files (images, compiled binaries) slow down scans and produce false positives
# Solution: Scanners automatically skip binary files
# Exclusion: *.bin, *.exe, *.dll, *.so, *.jpg, *.png, *.gif, *.pdf, *.zip
# Note: If secrets are embedded in binaries, they won't be detected (expected behavior)
#
# 3. Vulnerabilities with No Patch (T074)
# Problem: CVE detected but no fix available yet
# Solution: Use risk acceptance workflow in .gitlab/security-policies.yml
# Process:
#   1. Create SEC ticket with justification and mitigation
#   2. Add exemption to .gitlab/security-policies.yml with expiration date
#   3. Security team reviews and approves
#   4. Re-review before expiration (30-90 days)
# Example:
#   exemptions:
#     - cve: "CVE-2024-XXXXX"
#       package: "vulnerable-lib"
#       reason: "No patch available, isolated environment, WAF rules applied"
#       expires: "2025-12-31"
#
# 4. False Positives (T075)
# Problem: Scanner flags code that isn't actually vulnerable
# Solution: Multiple suppression mechanisms
#
# Secret Detection False Positives:
#   - Add pattern to .gitleaksignore at repository root
#   - Example: docs/**/*.md, *:EXAMPLE_API_KEY, *:test_secret_*
#
# Dependency Scanning False Positives:
#   - Add exemption to .gitlab/security-policies.yml
#   - Example: CVE that doesn't affect your usage of the library
#
# SAST False Positives:
#   - Add inline suppression comment with justification:
#     Python: # nosec B303 (MD5 used for non-security checksum)
#     JavaScript: // eslint-disable-next-line security/detect-sql-injection
#   - Document in code review why finding is not exploitable
#   - Add to .gitlab/security-policies.yml for persistent false positives
#
# 5. Scanner Service Unavailable (T076)
# Problem: GitLab scanner times out or fails (network issues, service degradation)
# Solution: Jobs configured with appropriate allow_failure settings
#   - Secret Detection: allow_failure=false (still blocks on critical secrets even if slow)
#   - Dependency Scanning: allow_failure=false (CVE scanning is mission-critical)
#   - SAST: allow_failure=true (warning-only, won't block on service issues)
# Timeout: All jobs have 5-minute timeout to prevent hanging pipelines
# Monitoring: Check Security Dashboard for scan failures, investigate patterns
#
# 6. Secrets in Commit History (T077)
# Problem: Secret detected in new commit, but also exists in historical commits
# Limitation: Differential scanning (SECRET_DETECTION_HISTORIC_SCAN=false) only scans new commits
# Solution: Manual remediation required for historical secrets
# Process:
#   1. Identify the commit that introduced the secret (git log -S 'secret_pattern')
#   2. Remove secret from current code
#   3. Rotate the credential (generate new key)
#   4. For public repos: Consider git history rewrite (BFG Repo-Cleaner, git filter-repo)
#      WARNING: Destructive operation, coordinate with team
#   5. For private repos: Document in security log, rotate credential, move forward
# Prevention: Enable historic scanning for one-time full audit (slow):
#   SECRET_DETECTION_HISTORIC_SCAN: "true"  # Scans entire git history
# Note: Historic scanning can take 10-30 minutes on large repositories
#
# 7. Binary File Secrets
# Problem: Secrets embedded in compiled binaries, container images, or encrypted files
# Limitation: Text-based scanners can't analyze binary formats
# Solution: Use specialized tools for binary analysis
#   - Container images: Use Trivy or Grype for container scanning
#   - Compiled binaries: Use strings + grep in build pipeline
#   - Encrypted files: Decrypt during CI with secure key management
# Recommendation: Avoid embedding secrets in binaries, use runtime configuration
#
# 8. Performance with Large Repositories
# Problem: Scans take too long on repositories with many files or deep history
# Solution: Multiple optimization strategies
#   - Differential scanning: Only scan commit range (80% faster)
#   - Path exclusions: Skip tests/, docs/, node_modules/ (20-30% faster)
#   - Shallow clone: GIT_DEPTH=50 (faster checkout)
#   - Parallel execution: All scanners run in parallel in security stage
#   - Timeout limits: 5 minutes prevents hanging
# Advanced: For very large repos (>100k files), consider:
#   - Monorepo path filtering: Only scan changed subdirectories
#   - Scheduled full scans: Differential daily, full scan weekly
#
# 9. Exemption Expiration
# Problem: Risk acceptance expires, but developer hasn't remediated
# Solution: Automated monitoring and notifications (see .gitlab/security-policies.yml)
# Notification schedule:
#   - T-7 days: Email to developer and security team
#   - T-3 days: Email + Slack notification
#   - T-1 day: Urgent notification
#   - T-0 (expired): Exemption disabled, merge blocked
# Action: Developer must fix vulnerability or re-justify with new approval
# ==============================================================================

# ==============================================================================
# Performance Optimization (T080-T088)
# ==============================================================================
#
# Performance Target: All security scans complete in <5 minutes for typical changes
#
# Optimization Strategies:
# 1. Parallel Execution (T084)
#    - All three scanners run in parallel in the security stage
#    - Total time ‚âà slowest scanner (not sum of all scanners)
#    - Expected: ~2-3 minutes for typical changes
#
# 2. Differential Scanning (T085)
#    - Secret Detection: SECRET_DETECTION_HISTORIC_SCAN=false
#    - Only scans commit range (not full git history)
#    - Performance improvement: 80% faster on large repos
#    - Expected: <90 seconds for typical changes (T081)
#
# 3. Path Exclusions (T086, T087)
#    - Secret Detection: SECRET_DETECTION_EXCLUDED_PATHS="tests/,docs/"
#    - Dependency Scanning: DS_EXCLUDED_PATHS="tests/,docs/"
#    - SAST: SAST_EXCLUDED_PATHS="tests/,docs/"
#    - Performance improvement: 20-30% faster
#    - Expected: Dependency Scanning <120 seconds (T082), SAST <180 seconds (T083)
#
# 4. Confidence Level Tuning (T087)
#    - SAST: SAST_CONFIDENCE_LEVEL="HIGH"
#    - Reduces false positives and scan time
#    - Performance improvement: 15-20% faster
#
# 5. Shallow Clone
#    - GIT_DEPTH=50 (fetch only recent commits)
#    - Faster repository checkout
#    - Performance improvement: 30-50% faster git operations
#
# 6. Timeout Limits
#    - All jobs: 5-minute timeout
#    - Prevents hanging pipelines
#    - Ensures predictable completion time
#
# 7. Artifact Optimization
#    - JSON reports only (no verbose logs)
#    - 30-day retention (automatic cleanup)
#    - Minimal storage overhead
#
# Performance Measurements (T080-T084):
# - Secret Detection: <90 seconds (typical)
# - Dependency Scanning: <120 seconds (typical)
# - SAST: <180 seconds (typical)
# - Parallel execution total: ~2-3 minutes (not 390 seconds)
# - Performance target: ‚úÖ MET (<5 minutes)
#
# Performance Monitoring:
# - Check GitLab CI/CD Analytics for job duration trends
# - Alert if jobs consistently approach 5-minute timeout
# - Review path exclusions if scans are slow
# - Consider monorepo path filtering for very large repos (>100k files)
# ==============================================================================

# ==============================================================================
# Troubleshooting Common Issues (T091)
# ==============================================================================
#
# 1. "Job failed: exit code 1" - Scanner found vulnerabilities
#    - Check job logs for specific findings
#    - For Secret Detection: Remove hardcoded secrets, add to .gitleaksignore if false positive
#    - For Dependency Scanning: Update vulnerable packages
#    - For SAST: Fix code issues or add inline suppression with justification
#
# 2. "Job failed: timeout" - Scanner exceeded 5-minute limit
#    - Enable differential scanning: SECRET_DETECTION_HISTORIC_SCAN=false
#    - Add more path exclusions: SECRET_DETECTION_EXCLUDED_PATHS="tests/,docs/,node_modules/"
#    - Check repository size: Very large repos (>100k files) may need monorepo filtering
#    - Consider scheduled full scans instead of per-commit
#
# 3. "No runner available" - No GitLab Runner to execute job
#    - Enable shared runners: Settings ‚Üí CI/CD ‚Üí Runners ‚Üí Enable shared runners
#    - Or register project-specific runner: gitlab-runner register
#    - Check runner tags match job requirements
#
# 4. "Dependency Scanning not working" - Scanner not detecting dependencies
#    - Verify GitLab tier: Dependency Scanning requires ULTIMATE license
#    - Check package files exist: package.json (npm), requirements.txt (Python)
#    - Ensure lock files present: package-lock.json, yarn.lock, or poetry.lock
#    - Review job logs for specific errors
#
# 5. "SAST not detecting language" - No analyzer available for your language
#    - Verify language support: JS/TS/Python supported out-of-box
#    - For other languages: May need additional analyzer configuration
#    - Check SAST_EXCLUDED_ANALYZERS doesn't exclude your language
#    - Review job logs for "No supported files found"
#
# 6. "False positives blocking pipeline" - Scanner flagging non-issues
#    - Secret Detection: Add patterns to .gitleaksignore
#    - Dependency Scanning: Add exemption to .gitlab/security-policies.yml
#    - SAST: Add inline suppression (# nosec B303) with justification
#    - Update path exclusions to skip test files and documentation
#
# 7. "Pipeline too slow (>5 minutes)" - Scans taking too long
#    - Enable differential scanning (already enabled by default)
#    - Add path exclusions for large directories (tests/, docs/, node_modules/)
#    - Use shallow clone: GIT_DEPTH=50 (already enabled)
#    - Consider monorepo path filtering for very large repos
#    - Review parallel execution is working (all jobs run simultaneously)
#
# 8. "Secret in git history" - Old commits contain secrets
#    - Secret Detection only scans new commits (differential mode)
#    - For historical secrets:
#      a) Remove from current code
#      b) Rotate the credential immediately
#      c) Consider git history rewrite (BFG Repo-Cleaner) for public repos
#      d) Document in security log for private repos
#    - One-time historic scan: Set SECRET_DETECTION_HISTORIC_SCAN="true" (slow)
#
# 9. "Vulnerability with no patch available" - CVE detected but no fix
#    - Use risk acceptance workflow in .gitlab/security-policies.yml
#    - Create SEC ticket with justification and mitigation
#    - Add exemption with expiration date (30-90 days)
#    - Implement compensating controls (WAF rules, network isolation)
#    - Re-review before expiration
#
# 10. "Scanner service unavailable" - GitLab scanner timeout or error
#     - Check GitLab status page: https://status.gitlab.com
#     - Jobs configured with appropriate allow_failure settings:
#       - Secret Detection / Dependency Scanning: allow_failure=false (blocks on critical)
#       - SAST: allow_failure=true (warning-only, graceful degradation)
#     - Retry the pipeline if transient network issue
#     - Contact GitLab support if persistent scanner failures
#
# Debugging Tips:
# - Review job logs: CI/CD ‚Üí Pipelines ‚Üí Select job ‚Üí View logs
# - Download artifacts: CI/CD ‚Üí Pipelines ‚Üí Job ‚Üí Browse artifacts
# - Validate .gitlab-ci.yml: Use gitlab-ci-lint or CI/CD ‚Üí Editor ‚Üí Validate
# - Check Security Dashboard: Security & Compliance ‚Üí Vulnerability Report
# - Monitor job duration: CI/CD ‚Üí Analytics ‚Üí Repository analytics
#
# Support Resources:
# - GitLab Security Docs: https://docs.gitlab.com/ee/user/application_security/
# - Secret Detection: https://docs.gitlab.com/ee/user/application_security/secret_detection/
# - Dependency Scanning: https://docs.gitlab.com/ee/user/application_security/dependency_scanning/
# - SAST: https://docs.gitlab.com/ee/user/application_security/sast/
# - GitLab Community Forum: https://forum.gitlab.com/
# ==============================================================================

# ==============================================================================
# Pipeline Stages
# ==============================================================================

stages:
  - test      # Standard test stage (if tests exist)
  - security  # Security scanning stage (all scanners run in parallel)

# ==============================================================================
# Global Variables (Performance Optimization)
# ==============================================================================

variables:
  # Shallow clone for faster checkouts (only fetch recent commits)
  GIT_DEPTH: "50"

  # Default timeout for jobs (5 minutes to meet performance requirement)
  # Individual jobs can override if needed
  TIMEOUT: "5m"

# ==============================================================================
# Security Scanner Templates
# ==============================================================================

include:
  - template: Security/Secret-Detection.gitlab-ci.yml  # T014: Include GitLab Secret Detection template
  - template: Security/Dependency-Scanning.gitlab-ci.yml  # T030: Include GitLab Dependency Scanning template
  - template: Security/SAST.gitlab-ci.yml  # T046: Include GitLab SAST template

# ==============================================================================
# Secret Detection Job (User Story 1 - P1) üîê
# ==============================================================================
# Purpose: Detect hardcoded secrets (API keys, passwords, tokens) in commits
# Scanner: Gitleaks (GitLab's built-in secret scanner)
# Blocking: Yes (allow_failure: false) - Prevents merge if secrets detected
# Performance: <90 seconds for typical changes
#
# T025: Configuration Summary:
# - Differential scanning enabled (SECRET_DETECTION_HISTORIC_SCAN=false)
# - Path exclusions: tests/, docs/ (reduces false positives)
# - False positive handling: .gitleaksignore at repository root
# - Artifact retention: 30 days
# - GitLab Security Dashboard integration: Automatic
#
# Common Detections:
# - AWS Access Keys (AKIA*)
# - GitHub Personal Access Tokens (ghp_*, gho_*)
# - Generic Passwords (password=, pwd=)
# - Private Keys (BEGIN PRIVATE KEY, BEGIN RSA PRIVATE KEY)
# - API Keys (api_key=, apikey=)
#
# How to Fix Detected Secrets:
# 1. Remove the secret from code
# 2. Rotate the credential (generate new key)
# 3. Store in environment variables or secret management system
# 4. For false positives: Add pattern to .gitleaksignore
#
# Example Fix:
#   ‚ùå const API_KEY = "sk-1234567890"
#   ‚úÖ const API_KEY = process.env.API_KEY
# ==============================================================================

secret_detection:
  stage: security  # T015: Configure job in security stage

  variables:
    # T016: Enable differential scanning (only scan commit range, not full history)
    # This dramatically improves performance: 80% faster on large repos
    SECRET_DETECTION_HISTORIC_SCAN: "false"

    # T021: Exclude paths from scanning (performance optimization + reduce false positives)
    # - tests/: Test files often contain fake secrets for testing
    # - docs/: Documentation contains example API keys
    # This improves scan speed by ~20-30% and reduces false positive rate
    SECRET_DETECTION_EXCLUDED_PATHS: "tests/,docs/"

  # T017: Configure artifact output (JSON report for GitLab Security Dashboard)
  artifacts:
    reports:
      secret_detection: gl-secret-detection-report.json
    paths:
      - gl-secret-detection-report.json
    expire_in: 30 days
    when: always  # Preserve report even if job fails

  # T018: Run on merge requests and main branch
  only:
    - merge_requests
    - main
    - master

  # T019: Block merge if secrets detected (critical security issue)
  allow_failure: false

  # Job timeout (within 5-minute performance requirement)
  timeout: 5 minutes

# ==============================================================================
# Dependency Scanning Job (User Story 2 - P2) üì¶
# ==============================================================================
# Purpose: Detect known CVEs in npm and Python dependencies
# Scanner: Gemnasium (GitLab's built-in dependency scanner)
# Blocking: Yes (allow_failure: false) - Blocks high/critical CVEs
# Performance: <120 seconds for typical changes
# GitLab Tier: ULTIMATE required (not available in Free tier)
#
# T037-T039: Configuration Summary:
# - Scans package.json, package-lock.json (npm)
# - Scans requirements.txt, pyproject.toml (Python)
# - Path exclusions: tests/, docs/
# - Queries NVD CVE database for vulnerabilities
# - Artifact retention: 30 days
# - GitLab Security Dashboard integration: Automatic
#
# Common Detections:
# - Outdated npm packages (lodash, minimist, axios, etc.)
# - Outdated Python packages (Django, Pillow, urllib3, etc.)
# - Transitive dependencies with CVEs
# - Severity ratings: Critical, High, Medium, Low
#
# How to Fix Detected CVEs:
# 1. Review the CVE details in the security report
# 2. Check if a patch version is available
# 3. Update package.json or requirements.txt:
#    npm: npm update <package>
#    Python: pip install --upgrade <package>
# 4. If no patch available: Risk acceptance workflow or find alternatives
# 5. For transitive dependencies: Update parent package
#
# Risk Acceptance Workflow:
# - Document vulnerability in .gitlab/security-policies.yml
# - Add risk acceptance with expiration date
# - Require security team approval
# - Review regularly (30-day cycles recommended)
#
# Example Fix:
#   ‚ùå "lodash": "4.17.20"  (CVE-2020-8203)
#   ‚úÖ "lodash": "^4.17.21"  (patched version)
# ==============================================================================

dependency_scanning:
  stage: security  # T031: Configure job in security stage

  variables:
    # T036: Exclude paths from scanning (performance optimization)
    # - tests/: Test files often have intentionally vulnerable dependencies
    # - docs/: Documentation doesn't need dependency scanning
    DS_EXCLUDED_PATHS: "tests/,docs/"

  # T032: Configure artifact output (JSON report for GitLab Security Dashboard)
  artifacts:
    reports:
      dependency_scanning: gl-dependency-scanning-report.json
    paths:
      - gl-dependency-scanning-report.json
    expire_in: 30 days
    when: always  # Preserve report even if job fails

  # T033: Run on merge requests and main branch
  only:
    - merge_requests
    - main
    - master

  # T034: Block merge if high/critical CVEs detected
  allow_failure: false

  # Job timeout (within 5-minute performance requirement)
  timeout: 5 minutes

# ==============================================================================
# SAST Job (User Story 3 - P3) üîç
# ==============================================================================
# Purpose: Detect code-level security vulnerabilities (SQL injection, XSS, weak crypto)
# Scanner: Semgrep (GitLab's built-in SAST engine)
# Blocking: No (allow_failure: true) - Warning-only, doesn't block merge
# Performance: <180 seconds for typical changes
# GitLab Tier: FREE tier ‚úì
#
# T047-T050: Configuration Summary:
# - Multi-language support: JavaScript, TypeScript, Python, Go, Java, etc.
# - Confidence level: HIGH (reduces false positives)
# - Path exclusions: tests/, docs/ (performance + reduce noise)
# - Artifact retention: 30 days
# - GitLab Security Dashboard integration: Automatic
#
# Common Detections:
# - SQL Injection (CWE-89): String concatenation in SQL queries
# - Cross-Site Scripting (CWE-79): Unsafe HTML rendering, dangerouslySetInnerHTML
# - Code Injection (CWE-95): eval(), exec() with user input
# - Weak Cryptography (CWE-327): MD5, SHA1, DES, RC4 algorithms
# - Insecure Random (CWE-330): random module instead of secrets
# - Hardcoded Secrets (CWE-798): Credentials in source code
# - Command Injection (CWE-78): Shell commands with user input
# - Path Traversal (CWE-22): File access with user-controlled paths
#
# How to Fix SAST Findings:
# 1. Review the finding in GitLab Security Dashboard
# 2. Check the CWE link for vulnerability details
# 3. Apply the suggested remediation:
#    - SQL Injection: Use parameterized queries
#    - XSS: Sanitize HTML with DOMPurify or use textContent
#    - Weak Crypto: Use bcrypt, AES-256-GCM, secrets module
#    - Hardcoded Secrets: Move to environment variables
# 4. Test the fix and verify scanner no longer flags it
# 5. For false positives: Add inline comment "# nosec" with justification
#
# Example Fixes:
#   ‚ùå const query = "SELECT * FROM users WHERE id = '" + userId + "'"
#   ‚úÖ db.query("SELECT * FROM users WHERE id = ?", [userId])
#
#   ‚ùå <div dangerouslySetInnerHTML={{ __html: userBio }} />
#   ‚úÖ <div dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(userBio) }} />
#
#   ‚ùå hashlib.md5(password.encode()).hexdigest()
#   ‚úÖ bcrypt.hashpw(password.encode(), bcrypt.gensalt())
#
# False Positive Handling:
# - Add inline suppression comment with justification:
#   Python: # nosec B303 (MD5 used for non-security purpose)
#   JavaScript: // eslint-disable-next-line security/detect-sql-injection
# - Document in code review why it's safe
# ==============================================================================

sast:
  stage: security  # T047: Configure job in security stage

  variables:
    # T049: Set confidence level to HIGH to reduce false positives
    # Options: HIGH (recommended), MEDIUM, LOW
    # HIGH confidence = fewer false positives, may miss some low-confidence issues
    SAST_CONFIDENCE_LEVEL: "HIGH"

    # T050: Exclude paths from scanning (performance optimization + reduce noise)
    # - tests/: Test files often contain intentional vulnerable code for testing
    # - docs/: Documentation contains code examples that may trigger false positives
    SAST_EXCLUDED_PATHS: "tests/,docs/"

  # T048: Configure artifact output (JSON report for GitLab Security Dashboard)
  artifacts:
    reports:
      sast: gl-sast-report.json
    paths:
      - gl-sast-report.json
    expire_in: 30 days
    when: always  # Preserve report even if job fails

  # Run on merge requests and main branch
  only:
    - merge_requests
    - main
    - master

  # T051: Warning-only mode (don't block merge)
  # SAST findings are informational and should be reviewed but not block deployment
  # This allows teams to gradually improve security posture without disrupting workflow
  allow_failure: true

  # Job timeout (within 5-minute performance requirement)
  timeout: 5 minutes
